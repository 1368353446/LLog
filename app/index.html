<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>LLog</title>
    <style>
        :root {
            --bg: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            --card: rgba(255, 255, 255, 0.85);
            --card-hover: rgba(255, 255, 255, 0.95);
            --accent: linear-gradient(135deg, #3b82f6, #1e40af);
            --accent-light: rgba(59, 130, 246, 0.1);
            --accent-border: rgba(59, 130, 246, 0.2);
            --muted: #64748b;
            --text: #1e293b;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border: rgba(148, 163, 184, 0.2);
            --shadow-sm: 0 2px 8px rgba(15, 23, 42, 0.08);
            --shadow-md: 0 8px 25px rgba(15, 23, 42, 0.12);
            --shadow-lg: 0 16px 40px rgba(15, 23, 42, 0.15);
            --radius: 16px;
            --radius-sm: 10px;
            --gap: 18px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                "Helvetica Neue", Arial, sans-serif;
        }

        * {
            box-sizing: border-box;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            overflow-x: hidden;
        }

        /* Layout */
        .wrap {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            grid-template-rows: auto 1fr 120px;
            gap: var(--gap);
            padding: var(--gap);
            height: 100vh;
            box-sizing: border-box;
        }

        header {
            grid-column: 1/-1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 16px;
            background: var(--card);
            border-radius: var(--radius);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border);
            animation: slideDown 0.6s ease-out;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            background: var(--accent);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .panel {
            background: var(--card);
            border-radius: var(--radius);
            padding: 12px;
            box-shadow: var(--shadow-md);
            overflow: auto;
            border: 1px solid var(--border);
            backdrop-filter: blur(10px);
            animation: fadeInUp 0.6s ease-out;
            animation-fill-mode: both;
            max-height: calc(100vh - 200px);
        }

        .left {
            animation-delay: 0.1s;
        }

        .center {
            display: flex;
            flex-direction: column;
            gap: 12px;
            animation-delay: 0.2s;
            height: 100%;
        }

        .right {
            animation-delay: 0.3s;
        }

        /* Center Editor */
        .mode-bar {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 5px;
            background: var(--accent-light);
            border-radius: var(--radius-sm);
            border: 1px solid var(--accent-border);
        }

        .mode-btn {
            padding: 8px 14px;
            border-radius: var(--radius-sm);
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            color: var(--muted);
            position: relative;
            overflow: hidden;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.5);
            color: var(--text);
            transform: translateY(-1px);
        }

        .mode-btn.active {
            background: var(--accent);
            color: white;
            box-shadow: var(--shadow-sm);
            transform: translateY(-1px);
        }

        .editor {
            background: var(--card-hover);
            border-radius: var(--radius);
            padding: 14px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
            height: 100%;
        }

        input,
        textarea,
        select {
            padding: 12px 14px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.7);
            font-family: inherit;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px var(--accent-light);
            background: white;
            transform: translateY(-1px);
        }

        textarea.large {
            min-height: 250px;
            resize: vertical;
            font-family: inherit;
        }

        .meta-row {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .actions {
            display: flex;
            gap: 12px;
            margin-top: 8px;
        }

        .btn {
            background: var(--accent);
            color: white;
            padding: 12px 24px;
            border-radius: var(--radius-sm);
            border: none;
            cursor: pointer;
            font-weight: 500;
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.ghost {
            background: transparent;
            color: var(--muted);
            border: 1px solid var(--border);
        }

        .btn.ghost:hover {
            background: var(--accent-light);
            color: #3b82f6;
            border-color: var(--accent-border);
        }

        /* Lists */
        .list-title {
            font-weight: 600;
            color: var(--text);
            margin-bottom: 12px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .list-title::before {
            content: "";
            width: 4px;
            height: 16px;
            background: var(--accent);
            border-radius: 2px;
        }

        .task,
        .topic {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            border-radius: var(--radius-sm);
            background: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
            border: 1px solid var(--border);
            position: relative;
            cursor: pointer;
            animation: slideInLeft 0.4s ease-out;
            font-size: 14px;
            font-weight: 400;
            color: var(--text);
            line-height: 1.4;
        }

        .task:hover,
        .topic:hover {
            background: var(--card-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-sm);
        }

        .item-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chk {
            width: 18px;
            height: 18px;
            border-radius: 5px;
            cursor: pointer;
            accent-color: var(--success);
        }

        /* Icons */
        .more-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
        }

        .task:hover .more-btn,
        .topic:hover .more-btn {
            opacity: 1;
        }

        .more-btn:hover {
            background: white;
            transform: scale(1.1);
            box-shadow: var(--shadow-sm);
        }

        /* Menu */
        .menu-card {
            position: fixed;
            background: white;
            border-radius: var(--radius-sm);
            padding: 8px;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            min-width: 180px;
            border: 1px solid var(--border);
            animation: fadeIn 0.2s ease-out;
        }

        .menu-card button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 10px 12px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.15s ease;
        }

        .menu-card button:hover {
            background: var(--accent-light);
            color: #3b82f6;
        }



        /* Timeline */
        .timeline-bar {
            grid-column: 1/-1;
            height: 120px;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: slideUp 0.6s ease-out 0.4s both;
        }

        .timeline-inner {
            width: 100%;
            background: var(--card);
            border-radius: var(--radius);
            padding: 6px 10px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-md);
            overflow: auto;
            backdrop-filter: blur(10px);
            /* ‰ºòÂåñÊªöÂä®Êù°Ê†∑Âºè */
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

        /* Â¢ûÂº∫ÁâàÊó∂Èó¥ËΩ¥ÊªöÂä®Êù°Ê†∑Âºè */
        .timeline-inner::-webkit-scrollbar {
            height: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
        }

        .timeline-inner::-webkit-scrollbar-track {
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.1), rgba(30, 64, 175, 0.1));
            border-radius: 5px;
            border: 1px solid rgba(59, 130, 246, 0.1);
        }

        .timeline-inner::-webkit-scrollbar-thumb {
            background: linear-gradient(90deg, #3b82f6, #1e40af);
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .timeline-inner::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(90deg, #2563eb, #1d4ed8);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
            transform: scaleY(1.2);
        }

        .timeline-inner::-webkit-scrollbar-thumb:active {
            background: linear-gradient(90deg, #1d4ed8, #1e3a8a);
        }

        /* Firefox ÊªöÂä®Êù°Ê†∑Âºè */
        .timeline-inner {
            scrollbar-width: thin;
            scrollbar-color: #3b82f6 rgba(59, 130, 246, 0.1);
        }

        .timeline-inner::-webkit-scrollbar {
            transition: all 0.3s ease;
        }

        .timeline-inner:not(:hover)::-webkit-scrollbar {
            height: 6px;
        }

        .timeline-inner:hover::-webkit-scrollbar {
            height: 12px;
        }

        /* ÊªöÂä®Êù°ÊãñÊãΩÊó∂ÁöÑËßÜËßâÂèçÈ¶à */
        .timeline-inner::-webkit-scrollbar-thumb:active {
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);
        }

        /* ‰∏∫Êó∂Èó¥ËΩ¥ÂÆπÂô®Ê∑ªÂä†ÂæÆÂ¶ôÁöÑÂÜÖÈò¥ÂΩ± */
        .timeline-inner {
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        /* Êó∂Èó¥ËΩ¥ÂÆπÂô® */
        .timeline {
            display: flex;
            gap: 15px;
            align-items: center;
            padding: 10px 8px;
            position: relative;
        }

        /* Ê∑ªÂä†Êó∂Èó¥ËΩ¥‰∏ªÁ∫ø */
        .timeline::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(to right, #3b82f6, #1e40af);
            transform: translateY(-50%);
            box-shadow: 0 0 2px rgba(59, 130, 246, 0.3);
            z-index: 0;
        }

        .node {
            min-width: 170px;
            flex: 0 0 auto;
            padding: 10px 12px;
            border-radius: var(--radius-sm);
            background: white;
            border: 1px solid var(--border);
            cursor: pointer;
            position: relative;
            box-shadow: var(--shadow-sm);
            animation: scaleIn 0.4s ease-out;
            animation-fill-mode: both;
            z-index: 1;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .node:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: var(--shadow-lg);
            background: var(--card-hover);
        }

        .node .title {
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 130px;
            color: var(--text);
            margin-bottom: 4px;
            font-size: 13px;
        }

        .node time {
            display: block;
            font-size: 10px;
            color: var(--muted);
            font-weight: 500;
            margin-bottom: 6px;
        }

        .node .content {
            display: none;
        }

        .node .topic-tag {
            display: inline-block;
            background: var(--accent-light);
            color: #3b82f6;
            padding: 2px 6px;
            border-radius: 20px;
            font-size: 10px;
            font-weight: 500;
        }

        .node .delete-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 18px;
            height: 18px;
            border: none;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .node:hover .delete-btn {
            display: flex;
        }

        .node .delete-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            transform: scale(1.1);
        }

        /* Header Controls */
        #searchInput {
            width: 240px;
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }

        /* Save Status */
        .btn.saving {
            background: var(--warning) !important;
        }

        .btn.saved {
            background: var(--success) !important;
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Responsive */
        @media (max-width: 1000px) {
            .wrap {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
            }

            .timeline-bar {
                height: 180px;
            }

            #searchInput {
                width: 200px;
            }
        }

        /* Scroll styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--muted);
        }

        /* Loading states */
        .loading {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        /* Enhanced focus states */
        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 3px var(--accent-light);
        }

        /* Status indicators */
        .task.completed {
            opacity: 0.7;
            background: rgba(16, 185, 129, 0.05);
        }

        .topic.completed {
            opacity: 0.7;
            background: rgba(16, 185, 129, 0.05);
        }

        /* Message box styles */
        .message-box {
            background: white;
            opacity: 0;
            transition: opacity 0.3s ease-out;
            backdrop-filter: blur(10px);
        }

        .message-box.show {
            opacity: 1;
        }

        .message-box.info {
            background: var(--accent-light);
            color: #3b82f6;
            border: 1px solid var(--accent-border);
        }

        .message-box.success {
            background: rgba(16, 185, 129, 0.15);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .message-box.warning {
            background: rgba(245, 158, 11, 0.15);
            color: #f59e0b;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .message-box.error {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
    </style>
</head>

<body>

    <div class="wrap">
        <header>
            <div style="display: flex; align-items: center; gap: 15px;">
                <h1>‚ú® LLog</h1>
                <div class="server-controls" style="font-size: 12px;">
                    <span id="serverStatus" class="server-status" style="font-size: 12px;">üîÑ Ê£ÄÊµã‰∏≠...</span>
                    <button id="btnCheckServer" class="btn" style="font-size: 12px; padding: 4px 8px;">üîÑ Ê£ÄÊµãÊúçÂä°</button>
                </div>
            </div>

            <div style="display: flex; gap: 8px; align-items: center">
                <input id="searchInput" placeholder="üîç ÊêúÁ¥¢ÔºàÊåâ‰∏ªÈ¢òÊàñÂÜÖÂÆπÔºâ" />
                <input id="fileImport" type="file" accept="application/json" style="display: none" />
                <label class="mode-btn" id="btnImportLbl" style="border: 1px solid var(--border); cursor: pointer">üì• ÂØºÂÖ•
                    JSON</label>
                <label class="mode-btn" id="btnExport" style="border: 1px solid var(--border); cursor: pointer">üì§ ÂØºÂá∫
                    JSON</label>
            </div>
        </header>

        <!-- Ê∂àÊÅØÊèêÁ§∫Ê°Ü -->
        <div id="messageContainer"
            style="grid-column: 1/-1; position: fixed; top: 20px; left: 45%; transform: translateX(-50%); z-index: 1000; display: none;">
            <div id="messageBox" class="message-box" style="
                padding: 16px 32px;
                border-radius: var(--radius-sm);
                font-size: 14px;
                font-weight: 500;
                text-align: center;
                box-shadow: var(--shadow-lg);
                animation: fadeIn 0.3s ease-out;
                min-width: 400px;
                max-width: 600px;
                background: white;
                border: 1px solid var(--border);
            "></div>
        </div>

        <!-- left: tasks -->
        <aside class="panel left">
            <div class="list-title">üìã ËÆ°Âàí</div>
            <div id="taskList"></div>
        </aside>

        <!-- center: big editor -->
        <main class="panel center">
            <div class="mode-bar">
                <button class="mode-btn active" data-mode="add-event">
                    üìÖ Ê∑ªÂä†‰∫ã‰ª∂
                </button>
                <button class="mode-btn" data-mode="add-task">‚úÖ Ê∑ªÂä†ËÆ°Âàí</button>
                <button class="mode-btn" data-mode="add-topic">üè∑Ô∏è Ê∑ªÂä†‰∏ªÈ¢ò</button>
                <button class="mode-btn" data-mode="edit">‚úèÔ∏è Êü•Áúã / ÁºñËæë</button>
                <div style="flex: 1"></div>
                <div style="color: var(--muted); font-size: 13px; font-weight: 500">
                    üí° ÁÇπÂáªÂ∫ïÈÉ®Êó∂Èó¥ËΩ¥Êàñ‰æßËæπÈ°π‰ª•Âú®Ê≠§Êü•Áúã/ÁºñËæë
                </div>
            </div>

            <div class="editor">
                <input id="itemTitle" placeholder="‚úèÔ∏è Ê†áÈ¢òÔºàÂØπ‰∫ã‰ª∂ÂèñÈ¶ñË°åÔºåÊàñ‰∏ªÈ¢òÂêç/‰ªªÂä°Ê†áÈ¢òÔºâ" />
                <textarea id="itemBody" class="large" placeholder="üìù ËØ¶ÊÉÖÊàñÁ¨îËÆ∞ÔºàÂú®ËøôÈáåÊü•Áúã/ÁºñËæëÂÆåÊï¥ÂÜÖÂÆπÔºâ"></textarea>
                <div class="meta-row">
                    <select id="bodyTopicSelect">
                        <option value="">üè∑Ô∏è ÂÖ≥ËÅî‰∏ªÈ¢òÔºàÂèØÈÄâÔºâ</option>
                    </select>
                    <div style="flex: 1"></div>
                    <button class="btn" id="saveBtn">üíæ ‰øùÂ≠ò</button>
                    <button class="btn ghost" id="cancelBtn">‚ùå ÂèñÊ∂à</button>
                </div>
            </div>
        </main>

        <!-- right: topics -->
        <aside class="panel right">
            <div style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
          ">
                <div class="list-title">üè∑Ô∏è ‰∏ªÈ¢ò</div>
            </div>
            <div id="topicList"></div>
        </aside>

        <!-- bottom timeline -->
        <div class="timeline-bar">
            <div class="timeline-inner">
                <div class="timeline" id="timeline"></div>
            </div>
        </div>
    </div>

    <script>
        // =============================================================================
        // Node.js Êú¨Âú∞ÊúçÂä°Ê£ÄÊµãÂíåÂàùÂßãÂåñ
        // =============================================================================
        let hasLocalServer = false;
        let serverURL = 'http://localhost:3001'; // ÈªòËÆ§Êú¨Âú∞ÊúçÂä°Âú∞ÂùÄ

        // Ê£ÄÊµãÊú¨Âú∞ÊúçÂä°ÊòØÂê¶ÂèØÁî®
        async function checkLocalServer() {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 3000);

            try {
                const response = await fetch(`${serverURL}/api/health`, {
                    method: 'GET',
                    signal: controller.signal
                });
                clearTimeout(timeout);

                if (response.ok) {
                    console.log('Êú¨Âú∞ÊúçÂä°ËøûÊé•ÊàêÂäü');
                    hasLocalServer = true;
                    return true;
                }
            } catch (error) {
                console.log('Êú¨Âú∞ÊúçÂä°Êú™ÂêØÂä®ÊàñËøûÊé•Â§±Ë¥•', error);
            }

            hasLocalServer = false;
            return false;
        }

        // API ËØ∑Ê±ÇÂ∞ÅË£Ö
        async function apiRequest(endpoint, options = {}) {
            if (!hasLocalServer) {
                throw new Error('Êú¨Âú∞ÊúçÂä°‰∏çÂèØÁî®');
            }

            const response = await fetch(`${serverURL}/api${endpoint}`, {
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                },
                ...options
            });

            if (!response.ok) {
                throw new Error(`ÊúçÂä°Âô®ÈîôËØØ: ${response.status}`);
            }

            return response.json();
        }

        // =============================================================================
        // Êï∞ÊçÆÂ≠òÂÇ®ÁÆ°ÁêÜÔºàÂèåÈáçÂ§á‰ªΩÔºâ
        // =============================================================================
        const STORAGE_KEY = "timeline_v3";
        let state = { events: [], topics: [], tasks: [] };

        // Áªü‰∏ÄÁöÑÊï∞ÊçÆ‰øùÂ≠òÂáΩÊï∞ÔºàÂèåÈáçÂ§á‰ªΩÔºâ
        async function saveData() {
            try {
                // ÂßãÁªà‰øùÂ≠òÂà∞ localStorageÔºà‰Ωú‰∏∫Â§á‰ªΩÔºâ
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));

                // Â¶ÇÊûúÊúâÊú¨Âú∞ÊúçÂä°ÔºåÂêåÊó∂‰øùÂ≠òÂà∞Êñá‰ª∂
                if (hasLocalServer) {
                    try {
                        await apiRequest('/data', {
                            method: 'POST',
                            body: JSON.stringify(state)
                        });
                        console.log('Êï∞ÊçÆÂ∑≤‰øùÂ≠òÂà∞Êú¨Âú∞Êñá‰ª∂ÂíåÊµèËßàÂô®Â≠òÂÇ®');
                    } catch (error) {
                        console.warn('Êú¨Âú∞Êñá‰ª∂‰øùÂ≠òÂ§±Ë¥•Ôºå‰ªÖ‰øùÂ≠òÂà∞ÊµèËßàÂô®Â≠òÂÇ®:', error.message);
                    }
                } else {
                    console.log('Êï∞ÊçÆÂ∑≤‰øùÂ≠òÂà∞ÊµèËßàÂô®Â≠òÂÇ®');
                }
            } catch (error) {
                console.error('Êï∞ÊçÆ‰øùÂ≠òÂ§±Ë¥•:', error);
                throw error;
            }
        }

        // Áªü‰∏ÄÁöÑÊï∞ÊçÆÂä†ËΩΩÂáΩÊï∞Ôºà‰ºòÂÖàÊú¨Âú∞Êñá‰ª∂Ôºâ
        async function loadData() {
            try {
                if (hasLocalServer) {
                    // ‰ºòÂÖà‰ªéÊú¨Âú∞Êñá‰ª∂Âä†ËΩΩ
                    try {
                        const data = await apiRequest('/data', { method: 'GET' });
                        if (data && (data.events || data.topics || data.tasks)) {
                            state = {
                                events: data.events || [],
                                topics: data.topics || [],
                                tasks: data.tasks || []
                            };
                            console.log('‰ªéÊú¨Âú∞Êñá‰ª∂Âä†ËΩΩÊï∞ÊçÆÊàêÂäü');
                            return;
                        }
                    } catch (error) {
                        console.warn('‰ªéÊú¨Âú∞Êñá‰ª∂Âä†ËΩΩÂ§±Ë¥•ÔºåÂ∞ùËØï‰ªéÊµèËßàÂô®Â≠òÂÇ®Âä†ËΩΩ:', error.message);
                    }
                }

                // ‰ªé localStorage Âä†ËΩΩÔºàÈôçÁ∫ßÊñπÊ°àÔºâ
                const raw = localStorage.getItem(STORAGE_KEY);
                if (raw) {
                    const parsed = JSON.parse(raw);
                    state = {
                        events: parsed.events || [],
                        topics: parsed.topics || [],
                        tasks: parsed.tasks || []
                    };
                    console.log('‰ªéÊµèËßàÂô®Â≠òÂÇ®Âä†ËΩΩÊï∞ÊçÆÊàêÂäü');

                    // Â¶ÇÊûúÊúâÊú¨Âú∞ÊúçÂä°ÔºåÂ∞ÜÊï∞ÊçÆÂêåÊ≠•Âà∞Êñá‰ª∂
                    if (hasLocalServer) {
                        try {
                            await saveData();
                            console.log('Êï∞ÊçÆÂ∑≤ÂêåÊ≠•Âà∞Êú¨Âú∞Êñá‰ª∂');
                        } catch (error) {
                            console.warn('Êï∞ÊçÆÂêåÊ≠•Â§±Ë¥•:', error.message);
                        }
                    }
                }
            } catch (error) {
                console.error('Êï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•:', error);
            }

            // Á°Æ‰øùÊï∞ÊçÆÁªìÊûÑÂÆåÊï¥
            state.events = state.events || [];
            state.topics = state.topics || [];
            state.tasks = state.tasks || [];
        }

        // =============================================================================
        // ‰øùÂ≠òÁä∂ÊÄÅÁÆ°ÁêÜ
        // =============================================================================
        let mode = "add-event";
        let currentEdit = null;
        let autoSaveTimer = null;
        let hasUnsavedChanges = false;
        let isAutoSaving = false;

        // ÂéüÂßãÂÜÖÂÆπË∑üË∏™
        let originalContent = {
            title: '',
            body: '',
            topic: ''
        };

        // =============================================================================
        // Â∑•ÂÖ∑ÂáΩÊï∞
        // =============================================================================
        const uid = () => Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
        const nowISO = () => new Date().toISOString();

        function escapeHtml(s) {
            return String(s || "").replace(
                /[&<>\"]/g,
                (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" }[c])
            );
        }

        // =============================================================================
        // DOM ÂºïÁî®
        // =============================================================================
        const taskList = document.getElementById("taskList");
        const topicList = document.getElementById("topicList");
        const timelineEl = document.getElementById("timeline");
        const titleInput = document.getElementById("itemTitle");
        const bodyInput = document.getElementById("itemBody");
        const topicSelect = document.getElementById("bodyTopicSelect");
        const saveBtn = document.getElementById("saveBtn");
        const cancelBtn = document.getElementById("cancelBtn");
        const fileImport = document.getElementById("fileImport");
        const searchInput = document.getElementById("searchInput");

        // =============================================================================
        // ‰øùÂ≠òÈÄªËæëÊ†∏ÂøÉ
        // =============================================================================

        // Ê£ÄÊµãÂÜÖÂÆπÂèòÂåñ
        function detectChanges() {
            const currentContent = {
                title: titleInput.value,
                body: bodyInput.value,
                topic: topicSelect.value
            };

            return (
                currentContent.title !== originalContent.title ||
                currentContent.body !== originalContent.body ||
                currentContent.topic !== originalContent.topic
            );
        }

        // Êõ¥Êñ∞ÂéüÂßãÂÜÖÂÆπÂü∫ÂáÜ
        function updateOriginalContent() {
            originalContent = {
                title: titleInput.value,
                body: bodyInput.value,
                topic: topicSelect.value
            };
            hasUnsavedChanges = false;
        }

        // ÈáçÁΩÆËá™Âä®‰øùÂ≠òÂÆöÊó∂Âô®
        function resetAutoSaveTimer() {
            if (autoSaveTimer) {
                clearTimeout(autoSaveTimer);
                autoSaveTimer = null;
            }

            // Âè™ÊúâÂú®ÁºñËæëÊ®°Âºè‰∏îÊúâÂÜÖÂÆπÂèòÂåñÊó∂ÊâçÂêØÂä®Ëá™Âä®‰øùÂ≠ò
            if (mode === "edit" && currentEdit && detectChanges()) {
                hasUnsavedChanges = true;
                autoSaveTimer = setTimeout(async () => {
                    if (hasUnsavedChanges && !isAutoSaving) {
                        await performSave(true);
                    }
                }, 10000); // 10ÁßíÂêéËá™Âä®‰øùÂ≠ò
            }
        }

        // ÊâßË°å‰øùÂ≠òÊìç‰Ωú
        async function performSave(isAutoSave = false) {
            if (isAutoSaving) return; // Èò≤Ê≠¢ÈáçÂ§ç‰øùÂ≠ò

            const title = titleInput.value.trim();
            const body = bodyInput.value.trim();
            const topicId = topicSelect.value || null;

            // ÊòæÁ§∫‰øùÂ≠òÁä∂ÊÄÅ
            if (isAutoSave) {
                isAutoSaving = true;
                updateSaveButtonStatus('saving', 'üîÑ Ëá™Âä®‰øùÂ≠ò‰∏≠...');
            } else {
                updateSaveButtonStatus('saving', 'üíæ ‰øùÂ≠ò‰∏≠...');
            }

            try {
                if (mode === "edit" && currentEdit) {
                    // ÁºñËæëÊ®°Âºè‰øùÂ≠ò
                    if (!title && !body) {
                        if (!isAutoSave) showMessage('ËØ∑ËæìÂÖ•ÂÜÖÂÆπ', 'warning');
                        return;
                    }

                    await saveEditContent(title, body, topicId, isAutoSave);

                } else {
                    // Êñ∞Â¢ûÊ®°Âºè‰øùÂ≠ò
                    await saveNewContent(title, body, topicId);
                }

                // ‰øùÂ≠òÊàêÂäü
                await saveData();
                renderAll();

                if (isAutoSave) {
                    updateSaveButtonStatus('saved', '‚úÖ Â∑≤Ëá™Âä®‰øùÂ≠ò');
                    setTimeout(() => updateSaveButtonStatus(), 2000);
                } else {
                    updateSaveButtonStatus('saved', '‚úÖ Â∑≤‰øùÂ≠ò');
                    setTimeout(() => updateSaveButtonStatus(), 2000);
                    if (mode !== 'edit') {
                        clearEditor();
                    }
                }

                updateOriginalContent();

            } catch (error) {
                console.error('‰øùÂ≠òÂ§±Ë¥•:', error);
                updateSaveButtonStatus('error', '‚ùå ‰øùÂ≠òÂ§±Ë¥•');
                if (!isAutoSave) {
                    showMessage('‰øùÂ≠òÂ§±Ë¥•: ' + error.message, 'error');
                }
                setTimeout(() => updateSaveButtonStatus(), 3000);
            } finally {
                isAutoSaving = false;
            }
        }

        // ‰øùÂ≠òÁºñËæëÂÜÖÂÆπ
        async function saveEditContent(title, body, topicId, isAutoSave) {
            if (currentEdit.type === "event") {
                const ev = state.events.find(x => x.id === currentEdit.id);
                if (!ev) throw new Error('‰∫ã‰ª∂‰∏çÂ≠òÂú®');

                if (!title && isAutoSave) return; // Ëá™Âä®‰øùÂ≠òÊó∂Ê†áÈ¢ò‰∏∫Á©∫ÂàôË∑≥Ëøá
                if (!title && !isAutoSave) throw new Error('ËØ∑ËæìÂÖ•‰∫ã‰ª∂Ê†áÈ¢ò');

                ev.title = title;
                ev.text = body;
                ev.topic = topicId || null;

            } else if (currentEdit.type === "topic") {
                const t = state.topics.find(x => x.id === currentEdit.id);
                if (!t) throw new Error('‰∏ªÈ¢ò‰∏çÂ≠òÂú®');

                if (!title && isAutoSave) return;
                if (!title && !isAutoSave) throw new Error('ËØ∑ËæìÂÖ•‰∏ªÈ¢òÂêç');

                // Ê£ÄÊü•ÈáçÂêçÔºàÊéíÈô§Ëá™Â∑±Ôºâ
                if (title.toLowerCase() !== t.name.trim().toLowerCase()) {
                    const exists = state.topics.find(x =>
                        x.id !== t.id && x.name.trim().toLowerCase() === title.toLowerCase()
                    );
                    if (exists) throw new Error('Â≠òÂú®ÂêåÂêç‰∏ªÈ¢ò');
                    t.name = title.trim();
                }
                t.notes = body;

            } else if (currentEdit.type === "task") {
                const tk = state.tasks.find(x => x.id === currentEdit.id);
                if (!tk) throw new Error('‰ªªÂä°‰∏çÂ≠òÂú®');

                if (!title && isAutoSave) return;
                if (!title && !isAutoSave) throw new Error('ËØ∑ËæìÂÖ•‰ªªÂä°Ê†áÈ¢ò');

                tk.text = title;
                tk.notes = body;
            }
        }

        // ‰øùÂ≠òÊñ∞ÂÜÖÂÆπ
        async function saveNewContent(title, body, topicId) {
            if (mode === 'add-event') {
                if (!body && !title) throw new Error('ËØ∑ËæìÂÖ•‰∫ã‰ª∂ÂÜÖÂÆπ');
                addEvent(title, body, nowISO(), topicId);

            } else if (mode === 'add-task') {
                if (!title) throw new Error('ËØ∑ËæìÂÖ•‰ªªÂä°Ê†áÈ¢ò');
                addTask(title);

            } else if (mode === 'add-topic') {
                if (!title) throw new Error('ËØ∑ËæìÂÖ•‰∏ªÈ¢òÂêç');
                const res = addTopic(title);
                if (!res.ok) throw new Error(res.msg);
                updateTopic(res.t.id, { notes: body });
            }
        }

        // Êõ¥Êñ∞‰øùÂ≠òÊåâÈíÆÁä∂ÊÄÅ
        function updateSaveButtonStatus(status = '', text = 'üíæ ‰øùÂ≠ò') {
            saveBtn.textContent = text;
            saveBtn.className = 'btn' + (status ? ` ${status}` : '');
        }

        // ÊòæÁ§∫Ê∂àÊÅØÊèêÁ§∫
        function showMessage(message, type = 'info') {
            const container = document.getElementById('messageContainer');
            const messageBox = document.getElementById('messageBox');

            // ËÆæÁΩÆÊ∂àÊÅØÂÜÖÂÆπÂíåÊ†∑Âºè
            messageBox.textContent = message;
            messageBox.className = 'message-box ' + type;

            // ÊòæÁ§∫Ê∂àÊÅØÂÆπÂô®
            container.style.display = 'block';

            // Ëß¶ÂèëÊòæÁ§∫Âä®Áîª
            setTimeout(() => {
                messageBox.classList.add('show');
            }, 10);

            // 3ÁßíÂêéËá™Âä®ÈöêËóèÊ∂àÊÅØ
            setTimeout(() => {
                messageBox.classList.remove('show');
                setTimeout(() => {
                    container.style.display = 'none';
                }, 300);
            }, 3000);

            // ÂêåÊó∂ËæìÂá∫Âà∞ÊéßÂà∂Âè∞
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // Âú®ÁºñËæëÂô®Ë∑≥ËΩ¨Ââç‰øùÂ≠òÂΩìÂâçÂÜÖÂÆπ
        async function saveBeforeSwitch() {
            if (mode === "edit" && currentEdit && hasUnsavedChanges && !isAutoSaving) {
                try {
                    await performSave(true); // Ëá™Âä®‰øùÂ≠ò
                } catch (error) {
                    console.error('ÂàáÊç¢Ââç‰øùÂ≠òÂ§±Ë¥•:', error);
                }
            }
        }

        // =============================================================================
        // ÁºñËæëÂô®ÁÆ°ÁêÜ
        // =============================================================================

        function clearEditor() {
            titleInput.value = '';
            bodyInput.value = '';
            topicSelect.value = '';
            currentEdit = null;
            updateOriginalContent();

            if (autoSaveTimer) {
                clearTimeout(autoSaveTimer);
                autoSaveTimer = null;
            }
        }

        async function loadIntoEditor(type, id) {
            // ÂàáÊç¢Ââç‰øùÂ≠ò
            await saveBeforeSwitch();

            if (type === 'event') {
                const ev = state.events.find(x => x.id === id);
                if (!ev) return;
                titleInput.value = ev.title || '';
                bodyInput.value = ev.text || '';
                topicSelect.value = ev.topic || '';
            } else if (type === 'topic') {
                const t = state.topics.find(x => x.id === id);
                if (!t) return;
                titleInput.value = t.name;
                bodyInput.value = t.notes || '';
                topicSelect.value = '';
            } else if (type === 'task') {
                const tk = state.tasks.find(x => x.id === id);
                if (!tk) return;
                titleInput.value = tk.text;
                bodyInput.value = tk.notes || '';
                topicSelect.value = '';
            }

            updateOriginalContent();
        }

        // =============================================================================
        // Ê∏≤ÊüìÂáΩÊï∞Ôºà‰øùÊåÅÂéüÊúâÈÄªËæë‰∏çÂèòÔºâ
        // =============================================================================

        function renderAll() {
            renderTasks();
            renderTopics();
            renderTimeline();
            populateTopicSelect();
        }

        function reorderListByCheck(listName, id, checked) {
            const arr = state[listName];
            const idx = arr.findIndex((x) => x.id === id);
            if (idx === -1) return;
            const item = arr.splice(idx, 1)[0];
            item.done = !!checked;
            insertItemInOrder(arr, item);
            saveData();
            renderAll();
        }

        // ÈÄöÁî®ÁöÑÈ°πÁõÆÊèíÂÖ•ÂáΩÊï∞Ôºå‰øùÊåÅÂãæÈÄâÁä∂ÊÄÅÁöÑÊ≠£Á°ÆÊéíÂ∫è
        function insertItemInOrder(arr, item) {
            if (item.done) {
                // ÂãæÈÄâÁöÑÈ°πÁõÆÊîæÂú®ÊâÄÊúâÊú™ÂãæÈÄâÈ°πÁõÆ‰πãÂêé
                const countUnchecked = arr.filter((x) => !x.done).length;
                arr.splice(countUnchecked, 0, item);
            } else {
                // Êú™ÂãæÈÄâÁöÑÈ°πÁõÆÊîæÂú®ÊâÄÊúâÂãæÈÄâÈ°πÁõÆ‰πãÂâç
                const firstChecked = arr.findIndex((x) => x.done);
                const insertIndex = firstChecked === -1 ? arr.length : firstChecked;
                arr.splice(insertIndex, 0, item);
            }
        }

        // ÁΩÆÈ°∂Êìç‰ΩúÔºà‰øùÊåÅÂãæÈÄâÁä∂ÊÄÅÊéíÂ∫èÔºâ
        function moveToTop(listName, id) {
            const arr = state[listName];
            const idx = arr.findIndex((x) => x.id === id);
            if (idx === -1) return;
            const item = arr.splice(idx, 1)[0];
            item.done = !!item.done; // ‰øùÊåÅÂéüÊúâÁöÑÂãæÈÄâÁä∂ÊÄÅ
            insertItemInOrder(arr, item);
            saveData();
            renderAll();
        }

        // ÁΩÆÂ∫ïÊìç‰ΩúÔºà‰øùÊåÅÂãæÈÄâÁä∂ÊÄÅÊéíÂ∫èÔºâ
        function moveToBottom(listName, id) {
            const arr = state[listName];
            const idx = arr.findIndex((x) => x.id === id);
            if (idx === -1) return;
            const item = arr.splice(idx, 1)[0];
            item.done = !!item.done; // ‰øùÊåÅÂéüÊúâÁöÑÂãæÈÄâÁä∂ÊÄÅ

            // ÂØπ‰∫éÁΩÆÂ∫ïÊìç‰ΩúÔºåÊàë‰ª¨ÈúÄË¶ÅÂ∞ÜÈ°πÁõÆÊîæÂú®ÂêåÁ±ªÈ°πÁõÆÔºàÂãæÈÄâÊàñÊú™ÂãæÈÄâÔºâÁöÑÊú´Â∞æ
            if (item.done) {
                // ÂãæÈÄâÁöÑÈ°πÁõÆÊîæÂú®ÊâÄÊúâÂãæÈÄâÈ°πÁõÆÁöÑÊú´Â∞æ
                arr.push(item);
            } else {
                // Êú™ÂãæÈÄâÁöÑÈ°πÁõÆÊîæÂú®ÊâÄÊúâÊú™ÂãæÈÄâÈ°πÁõÆÁöÑÊú´Â∞æÔºå‰ΩÜÂú®ÂãæÈÄâÈ°πÁõÆ‰πãÂâç
                const firstChecked = arr.findIndex((x) => x.done);
                const insertIndex = firstChecked === -1 ? arr.length : firstChecked;
                arr.splice(insertIndex, 0, item);
            }

            saveData();
            renderAll();
        }

        function renderTasks() {
            taskList.innerHTML = "";
            state.tasks.forEach((t, idx) => {
                const div = document.createElement("div");
                div.className = "task" + (t.done ? " completed" : "");
                div.style.animationDelay = `${idx * 0.1}s`;

                const left = document.createElement("div");
                left.className = "item-left";
                const chk = document.createElement("input");
                chk.type = "checkbox";
                chk.className = "chk";
                chk.checked = !!t.done;
                chk.onchange = () => {
                    reorderListByCheck("tasks", t.id, chk.checked);
                };
                const txt = document.createElement("div");
                txt.innerHTML = `<div style="font-weight:500">${escapeHtml(t.text)}</div>`;
                left.appendChild(chk);
                left.appendChild(txt);
                div.appendChild(left);

                const mBtn = document.createElement("div");
                mBtn.className = "more-btn";
                mBtn.innerHTML = "‚ãÆ";
                div.appendChild(mBtn);
                taskList.appendChild(div);

                div.onclick = async (e) => {
                    if (e.target.type === "checkbox" ||
                        e.target.classList.contains("more-btn") ||
                        e.target.closest(".more-btn")) return;

                    await saveBeforeSwitch();
                    mode = "edit";
                    currentEdit = { type: "task", id: t.id };
                    setModeButton();
                    await loadIntoEditor("task", t.id);
                };

                mBtn.onclick = (e) => {
                    openMenuForElement(mBtn, [
                        {
                            label: "üìç ÁΩÆÈ°∂",
                            action: async () => {
                                moveToTop("tasks", t.id);
                            },
                        },
                        {
                            label: "üìå ÁΩÆÂ∫ï",
                            action: async () => {
                                moveToBottom("tasks", t.id);
                            },
                        },
                        {
                            label: "‚¨ÜÔ∏è ‰∏äÁßª",
                            action: async () => {
                                if (idx > 0) {
                                    state.tasks.splice(idx, 1);
                                    state.tasks.splice(idx - 1, 0, t);
                                    await saveData();
                                    renderAll();
                                }
                            },
                        },
                        {
                            label: "‚¨áÔ∏è ‰∏ãÁßª",
                            action: async () => {
                                if (idx < state.tasks.length - 1) {
                                    state.tasks.splice(idx, 1);
                                    state.tasks.splice(idx + 1, 0, t);
                                    await saveData();
                                    renderAll();
                                }
                            },
                        },
                        {
                            label: "‚úèÔ∏è ÁºñËæë",
                            action: async () => {
                                await saveBeforeSwitch();
                                mode = "edit";
                                currentEdit = { type: "task", id: t.id };
                                setModeButton();
                                await loadIntoEditor("task", t.id);
                            },
                        },
                        {
                            label: "üóëÔ∏è Âà†Èô§",
                            action: async () => {
                                if (confirm("Âà†Èô§‰ªªÂä°Ôºü")) {
                                    state.tasks = state.tasks.filter((x) => x.id !== t.id);
                                    if (currentEdit?.type === "task" && currentEdit?.id === t.id) {
                                        clearEditor();
                                    }
                                    await saveData();
                                    renderAll();
                                }
                            },
                        },
                    ], e);
                };
            });
        }

        function renderTopics() {
            topicList.innerHTML = "";
            state.topics.forEach((t, idx) => {
                const box = document.createElement("div");
                box.className = "topic" + (t.done ? " completed" : "");
                box.style.animationDelay = `${idx * 0.1}s`;

                const left = document.createElement("div");
                left.className = "item-left";
                const chk = document.createElement("input");
                chk.type = "checkbox";
                chk.className = "chk";
                chk.checked = !!t.done;
                chk.onchange = () => {
                    reorderListByCheck("topics", t.id, chk.checked);
                };
                const h = document.createElement("h4");
                h.textContent = t.name;
                h.style.margin = "0";
                h.style.fontSize = "14px";
                h.style.fontWeight = "500";
                left.appendChild(chk);
                left.appendChild(h);
                box.appendChild(left);

                box.onclick = async (e) => {
                    if (e.target.type === "checkbox" ||
                        e.target.classList.contains("more-btn") ||
                        e.target.closest(".more-btn")) return;

                    await saveBeforeSwitch();
                    mode = "edit";
                    currentEdit = { type: "topic", id: t.id };
                    setModeButton();
                    await loadIntoEditor("topic", t.id);
                };

                const mBtn = document.createElement("div");
                mBtn.className = "more-btn";
                mBtn.innerHTML = "‚ãÆ";
                box.appendChild(mBtn);
                topicList.appendChild(box);

                mBtn.onclick = (e) => {
                    openMenuForElement(mBtn, [
                        {
                            label: "üìå ÁΩÆÈ°∂",
                            action: async () => {
                                moveToTop("topics", t.id);
                            },
                        },
                        {
                            label: "üìç ÁΩÆÂ∫ï",
                            action: async () => {
                                moveToBottom("topics", t.id);
                            },
                        },
                        {
                            label: "‚¨ÜÔ∏è ‰∏äÁßª",
                            action: async () => {
                                if (idx > 0) {
                                    state.topics.splice(idx, 1);
                                    state.topics.splice(idx - 1, 0, t);
                                    await saveData();
                                    renderAll();
                                }
                            },
                        },
                        {
                            label: "‚¨áÔ∏è ‰∏ãÁßª",
                            action: async () => {
                                if (idx < state.topics.length - 1) {
                                    state.topics.splice(idx, 1);
                                    state.topics.splice(idx + 1, 0, t);
                                    await saveData();
                                    renderAll();
                                }
                            },
                        },
                        {
                            label: "‚úèÔ∏è ÈáçÂëΩÂêç/ÁºñËæëÁ¨îËÆ∞",
                            action: async () => {
                                await saveBeforeSwitch();
                                mode = "edit";
                                currentEdit = { type: "topic", id: t.id };
                                setModeButton();
                                await loadIntoEditor("topic", t.id);
                            },
                        },
                        {
                            label: "üóëÔ∏è Âà†Èô§",
                            action: async () => {
                                if (confirm("Âà†Èô§‰∏ªÈ¢òÔºüÂØπÂ∫î‰∫ã‰ª∂Â∞ÜÂèñÊ∂àÂÖ≥ËÅî")) {
                                    state.topics = state.topics.filter((x) => x.id !== t.id);
                                    state.events.forEach((ev) => {
                                        if (ev.topic === t.id) ev.topic = null;
                                    });
                                    if (currentEdit?.type === "topic" && currentEdit?.id === t.id) {
                                        clearEditor();
                                    }
                                    await saveData();
                                    renderAll();
                                }
                            },
                        },
                    ], e);
                };
            });
        }

        function renderTimeline() {
            timelineEl.innerHTML = '';

            const q = (searchInput.value || '').trim().toLowerCase();
            const list = state.events.filter(ev => {
                if (!q) return true;
                const txt = (ev.text || '').toLowerCase();
                const topicName = ev.topic ?
                    (state.topics.find(t => t.id === ev.topic) || { name: '' }).name.toLowerCase() : '';
                return txt.includes(q) || topicName.includes(q);
            });

            list.sort((a, b) => new Date(b.ts) - new Date(a.ts)); // Êñ∞‰∫ã‰ª∂Âú®Ââç
            list.forEach((ev, idx) => {
                const node = document.createElement("div");
                node.className = "node";
                node.style.animationDelay = `${idx * 0.1}s`;

                const title = document.createElement("div");
                title.className = "title";
                title.textContent = ev.title || (ev.text ? ev.text.split(/\n/)[0] : "") || "(Êó†ÂÜÖÂÆπ)";

                const timeEl = document.createElement("time");
                timeEl.textContent = new Date(ev.ts).toLocaleString();

                // ‰∏çÂÜçÊ∑ªÂä†ÂÜÖÂÆπÈ¢ÑËßà

                // Ê∑ªÂä†‰∏ªÈ¢òÊ†áÁ≠æ
                const topicTag = document.createElement("div");
                topicTag.className = "topic-tag";
                const topic = ev.topic ? state.topics.find(t => t.id === ev.topic) : null;
                topicTag.textContent = topic ? topic.name : "Êó†‰∏ªÈ¢ò";
                topicTag.style.display = ev.topic ? "inline-block" : "none";

                const deleteBtn = document.createElement("button");
                deleteBtn.innerHTML = "√ó";
                deleteBtn.className = "delete-btn";

                deleteBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (confirm("Á°ÆËÆ§Âà†Èô§Ëøô‰∏™‰∫ã‰ª∂Ôºü")) {
                        state.events = state.events.filter((event) => event.id !== ev.id);
                        await saveData();
                        renderAll();
                        if (currentEdit?.type === "event" && currentEdit?.id === ev.id) {
                            clearEditor();
                        }
                    }
                };

                node.appendChild(title);
                node.appendChild(timeEl);
                node.appendChild(topicTag);
                node.appendChild(deleteBtn);
                timelineEl.appendChild(node);

                node.onclick = async () => {
                    await saveBeforeSwitch();
                    mode = "edit";
                    currentEdit = { type: "event", id: ev.id };
                    setModeButton();
                    await loadIntoEditor("event", ev.id);
                    node.scrollIntoView({ behavior: "smooth", inline: "center" });
                };
            });
        }

        function populateTopicSelect() {
            topicSelect.innerHTML = '<option value="">üè∑Ô∏è (‰∏çÂÖ≥ËÅî)</option>';
            state.topics
                .filter((t) => t.done !== true)
                .forEach((t) => {
                    const o = document.createElement("option");
                    o.value = t.id;
                    o.textContent = t.name;
                    topicSelect.appendChild(o);
                });
        }

        // =============================================================================
        // Êï∞ÊçÆÊìç‰ΩúÂáΩÊï∞Ôºà‰øùÊåÅÂéüÊúâÈÄªËæë‰∏çÂèòÔºâ
        // =============================================================================

        function addEvent(title, text, ts = null, topic = null) {
            const ev = {
                id: uid(),
                ts: ts || nowISO(),
                title: title || '',
                text: text || '',
                topic: topic || null,
            };
            state.events.push(ev);
        }

        function addTask(text) {
            const task = {
                id: uid(),
                text,
                done: false,
                notes: '',
                createdAt: nowISO()
            };
            state.tasks.unshift(task);
        }

        function addTopic(name) {
            if (!name) return { ok: false, msg: 'ÂêçÁß∞‰∏∫Á©∫' };
            const exists = state.topics.find(t =>
                t.name.trim().toLowerCase() === name.trim().toLowerCase()
            );
            if (exists) return { ok: false, msg: '‰∏ªÈ¢òÂ∑≤Â≠òÂú®' };

            const t = {
                id: uid(),
                name: name.trim(),
                notes: '',
                done: false,
                createdAt: nowISO()
            };

            state.topics.unshift(t);
            return { ok: true, t };
        }

        function updateTopic(id, data) {
            const t = state.topics.find((x) => x.id === id);
            if (!t) return;
            Object.assign(t, data);
        }

        // =============================================================================
        // ËèúÂçïÁ≥ªÁªüÔºà‰øùÊåÅÂéüÊúâÈÄªËæë‰∏çÂèòÔºâ
        // =============================================================================

        function openMenuForElement(anchor, items, event) {
            const parent = anchor.parentElement;
            const existing = parent.querySelector(".menu-card");
            if (existing) {
                existing.remove();
                return;
            }

            document.querySelectorAll(".menu-card").forEach((n) => n.remove());
            if (event) {
                event.stopPropagation();
            }

            const card = document.createElement("div");
            card.className = "menu-card";
            card.onclick = (e) => {
                e.stopPropagation();
            };

            items.forEach((it) => {
                const btn = document.createElement("button");
                btn.textContent = it.label;
                btn.onclick = async () => {
                    try {
                        await it.action();
                    } catch (e) {
                        console.error(e);
                    }
                    card.remove();
                };
                card.appendChild(btn);
            });

            document.body.appendChild(card);

            const rect = anchor.getBoundingClientRect();
            card.style.position = "fixed";
            card.style.left = rect.right - 180 + "px";

            const menuHeight = card.offsetHeight;
            const spaceBelow = window.innerHeight - rect.bottom - 10;
            const spaceAbove = rect.top - 10;

            if (spaceBelow < menuHeight && spaceAbove >= menuHeight) {
                card.style.top = rect.top - menuHeight - 5 + "px";
            } else {
                card.style.top = rect.bottom + 5 + "px";
            }
        }

        // =============================================================================
        // Êñá‰ª∂Êìç‰ΩúÔºàÊîØÊåÅÊú¨Âú∞ÊúçÂä°Ôºâ
        // =============================================================================

        async function exportData() {
            try {
                const dataStr = JSON.stringify(state, null, 2);
                const fileName = "timeline_export_" +
                    new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-") + ".json";

                if (hasLocalServer) {
                    // ÈÄöËøáÊú¨Âú∞ÊúçÂä°ÂØºÂá∫
                    try {
                        await apiRequest('/export', {
                            method: 'POST',
                            body: JSON.stringify({
                                data: state,
                                filename: fileName
                            })
                        });
                        showMessage('‚úÖ Êï∞ÊçÆÂ∑≤ÊàêÂäüÂØºÂá∫Âà∞Êú¨Âú∞Êñá‰ª∂Ôºö' + fileName, 'success');
                    } catch (error) {
                        console.warn('Êú¨Âú∞ÊúçÂä°ÂØºÂá∫Â§±Ë¥•Ôºå‰ΩøÁî®ÊµèËßàÂô®‰∏ãËΩΩ:', error.message);
                        // ÈôçÁ∫ßÂà∞ÊµèËßàÂô®‰∏ãËΩΩ
                        downloadAsFile(dataStr, fileName);
                    }
                } else {
                    // ÊµèËßàÂô®ÁéØÂ¢ÉÔºöÁõ¥Êé•‰∏ãËΩΩ
                    downloadAsFile(dataStr, fileName);
                }
            } catch (error) {
                console.error('ÂØºÂá∫Â§±Ë¥•:', error);
                showMessage('‚ùå ÂØºÂá∫Â§±Ë¥•: ' + error.message, 'error');
            }
        }

        // ÊµèËßàÂô®‰∏ãËΩΩÊñá‰ª∂
        function downloadAsFile(content, filename) {
            const blob = new Blob([content], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            showMessage('‚úÖ Êï∞ÊçÆÂ∑≤ÈÄöËøáÊµèËßàÂô®‰∏ãËΩΩÔºö' + filename, 'success');
        }

        async function importData() {
            // Áõ¥Êé•Ëß¶ÂèëÊñá‰ª∂ÈÄâÊã©Ôºå‰∏ç‰æùËµñÊú¨Âú∞ÊúçÂä°
            fileImport.click();
        }

        // Â§ÑÁêÜÂØºÂÖ•ÁöÑÊï∞ÊçÆÔºåÁîüÊàêÁº∫Â§±ÁöÑIDÂπ∂ÊéíÂ∫è‰∫ã‰ª∂
        function processImportedDataStructure(imported) {
            // Á°Æ‰øùÂü∫Êú¨ÁªìÊûÑÂ≠òÂú®
            const processed = {
                events: Array.isArray(imported.events) ? [...imported.events] : [],
                topics: Array.isArray(imported.topics) ? [...imported.topics] : [],
                tasks: Array.isArray(imported.tasks) ? [...imported.tasks] : []
            };

            // Â§ÑÁêÜ‰∫ã‰ª∂ÔºöÁîüÊàêÁº∫Â§±ÁöÑID
            processed.events = processed.events.map(event => {
                return {
                    ...event,
                    id: event.id || uid(),
                    ts: event.ts || new Date().toISOString()
                };
            });

            // Â§ÑÁêÜ‰∏ªÈ¢òÔºöÁîüÊàêÁº∫Â§±ÁöÑID
            processed.topics = processed.topics.map(topic => {
                return {
                    ...topic,
                    id: topic.id || uid(),
                    createdAt: topic.createdAt || new Date().toISOString()
                };
            });

            // Â§ÑÁêÜ‰ªªÂä°ÔºöÁîüÊàêÁº∫Â§±ÁöÑID
            processed.tasks = processed.tasks.map(task => {
                return {
                    ...task,
                    id: task.id || uid(),
                    createdAt: task.createdAt || new Date().toISOString()
                };
            });

            // ÊåâÊó∂Èó¥Êà≥ÂØπ‰∫ã‰ª∂ËøõË°åÊéíÂ∫èÔºàÂçáÂ∫èÔºâ
            processed.events.sort((a, b) => new Date(a.ts) - new Date(b.ts));

            return processed;
        }

        async function processImportedData(content) {
            try {
                const imported = JSON.parse(content);
                if (!imported) throw new Error("Ê†ºÂºèÈîôËØØ");

                // Â§ÑÁêÜÂØºÂÖ•ÁöÑÊï∞ÊçÆÔºöÁîüÊàêÁº∫Â§±ÁöÑIDÂπ∂ÊéíÂ∫è‰∫ã‰ª∂
                const processedData = processImportedDataStructure(imported);

                // Ëá™Âä®Â§á‰ªΩÂΩìÂâçÊï∞ÊçÆ
                try {
                    const backupData = JSON.stringify(state, null, 2);
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-");
                    const backupFileName = `llog_backup_${timestamp}.json`;

                    if (hasLocalServer) {
                        // ÈÄöËøáÊú¨Âú∞ÊúçÂä°Â§á‰ªΩ
                        await apiRequest('/export', {
                            method: 'POST',
                            body: JSON.stringify({
                                data: state,
                                filename: backupFileName
                            })
                        });
                    } else {
                        // ÊµèËßàÂô®ÁéØÂ¢ÉÔºöÁõ¥Êé•‰∏ãËΩΩÂ§á‰ªΩ
                        downloadAsFile(backupData, backupFileName);
                    }
                } catch (backupError) {
                    console.warn('Ëá™Âä®Â§á‰ªΩÂ§±Ë¥•:', backupError);
                }

                // Áõ¥Êé•ÊõøÊç¢Êï∞ÊçÆ
                state = processedData;
                await saveData();
                renderAll();
                showMessage('ÂØºÂÖ•ÂÆåÊàêÔºåÂéüÊï∞ÊçÆÂ∑≤Ëá™Âä®Â§á‰ªΩ', 'success');
            } catch (err) {
                showMessage('ÂØºÂÖ•Â§±Ë¥•Ôºö' + err.message, 'error');
            }
        }

        // =============================================================================
        // ‰∫ã‰ª∂ÁõëÂê¨Âô®ËÆæÁΩÆ
        // =============================================================================

        function setupEventListeners() {
            // ËæìÂÖ•ÂèòÂåñÁõëÂê¨
            titleInput.addEventListener('input', resetAutoSaveTimer);
            bodyInput.addEventListener('input', resetAutoSaveTimer);
            topicSelect.addEventListener('change', resetAutoSaveTimer);

            // ‰øùÂ≠òÊåâÈíÆ
            saveBtn.onclick = () => performSave(false);

            // ÂèñÊ∂àÊåâÈíÆ
            cancelBtn.onclick = () => {
                if (hasUnsavedChanges && !confirm('ÊúâÊú™‰øùÂ≠òÁöÑÊõ¥ÊîπÔºåÁ°ÆËÆ§ÂèñÊ∂àÔºü')) {
                    return;
                }
                clearEditor();
            };

            // Ê®°ÂºèÂàáÊç¢ÊåâÈíÆ
            document.querySelectorAll(".mode-btn").forEach((b) => {
                b.onclick = async () => {
                    await saveBeforeSwitch();

                    document.querySelectorAll(".mode-btn").forEach((x) => x.classList.remove("active"));
                    b.classList.add("active");
                    mode = b.dataset.mode;
                    clearEditor();
                };
            });

            // ÊêúÁ¥¢ËæìÂÖ•
            searchInput.addEventListener("input", () => {
                renderTimeline();
            });

            // ÂØºÂÖ•ÂØºÂá∫ÊåâÈíÆ
            const btnExport = document.getElementById("btnExport");
            btnExport.onclick = exportData;

            const btnImportLbl = document.getElementById("btnImportLbl");
            btnImportLbl.onclick = importData;

            // ÊµèËßàÂô®ÁéØÂ¢ÉÁöÑÊñá‰ª∂ËæìÂÖ•Â§ÑÁêÜ
            fileImport.onchange = async (e) => {
                const f = e.target.files[0];
                if (!f) return;

                const reader = new FileReader();
                reader.onload = async (ev) => {
                    await processImportedData(ev.target.result);
                };
                reader.readAsText(f);
                e.target.value = null;
            };


            // ÊúçÂä°Áä∂ÊÄÅÊ£ÄÊü•ÊåâÈíÆ
            const btnCheckServer = document.getElementById("btnCheckServer");
            if (btnCheckServer) {
                btnCheckServer.onclick = async () => {
                    updateServerStatus('checking');
                    const connected = await checkLocalServer();
                    updateServerStatus(connected ? 'connected' : 'disconnected');

                    if (connected) {
                        showMessage('Êú¨Âú∞ÊúçÂä°ËøûÊé•ÊàêÂäü', 'success');
                        // ÈáçÊñ∞Âä†ËΩΩÊï∞ÊçÆ‰ª•ÂêåÊ≠•
                        await loadData();
                        renderAll();
                    } else {
                        showMessage('Êú¨Âú∞ÊúçÂä°Êú™ÂêØÂä®', 'warning');
                    }
                };
            }

            // ÁÇπÂáªÂ§ñÈÉ®ÂÖ≥Èó≠ËèúÂçï
            document.addEventListener("click", (e) => {
                if (!e.target.closest(".menu-card") && !e.target.closest(".more-btn")) {
                    document.querySelectorAll(".menu-card").forEach((n) => n.remove());
                }
            });

            // ÈîÆÁõòÂø´Êç∑ÈîÆ
            document.addEventListener("keydown", async (e) => {
                // Ctrl+S ‰øùÂ≠ò
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    await performSave(false);
                }

                // Ctrl+Delete Âà†Èô§ÂΩìÂâçÁºñËæëÈ°π
                if (e.ctrlKey && e.key === "Delete" && currentEdit) {
                    await deleteCurrentEditItem();
                }
            });

        }

        // Êõ¥Êñ∞ÊúçÂä°Âô®Áä∂ÊÄÅÊòæÁ§∫
        function updateServerStatus(status) {
            const statusEl = document.getElementById("serverStatus");
            if (!statusEl) return;

            switch (status) {
                case 'checking':
                    statusEl.textContent = 'üîÑ Ê£ÄÊµã‰∏≠...';
                    statusEl.className = 'server-status checking';
                    break;
                case 'connected':
                    statusEl.textContent = 'üü¢ Â∑≤ËøûÊé•';
                    statusEl.className = 'server-status connected';
                    break;
                case 'disconnected':
                    statusEl.textContent = 'üî¥ Êú™ËøûÊé•';
                    statusEl.className = 'server-status disconnected';
                    break;
            }
        }

        async function deleteCurrentEditItem() {
            if (!currentEdit) return;

            if (currentEdit.type === "event") {
                if (confirm("Âà†Èô§ËØ•‰∫ã‰ª∂Ôºü")) {
                    state.events = state.events.filter(e => e.id !== currentEdit.id);
                    clearEditor();
                    await saveData();
                    renderAll();
                }
            } else if (currentEdit.type === "topic") {
                if (confirm("Âà†Èô§‰∏ªÈ¢òÔºüÂØπÂ∫î‰∫ã‰ª∂Â∞ÜÂèñÊ∂àÂÖ≥ËÅî")) {
                    state.topics = state.topics.filter(t => t.id !== currentEdit.id);
                    state.events.forEach(ev => {
                        if (ev.topic === currentEdit.id) ev.topic = null;
                    });
                    clearEditor();
                    await saveData();
                    renderAll();
                }
            } else if (currentEdit.type === "task") {
                if (confirm("Âà†Èô§‰ªªÂä°Ôºü")) {
                    state.tasks = state.tasks.filter(x => x.id !== currentEdit.id);
                    clearEditor();
                    await saveData();
                    renderAll();
                }
            }
        }

        function setModeButton() {
            document.querySelectorAll(".mode-btn").forEach((x) => x.classList.remove("active"));
            const btn = Array.from(document.querySelectorAll(".mode-btn")).find(
                (b) => b.dataset.mode === mode
            );
            if (btn) btn.classList.add("active");
        }

        // =============================================================================
        // Â∫îÁî®ÂàùÂßãÂåñ
        // =============================================================================

        async function initializeApp() {
            try {
                console.log('LLog Â∫îÁî®ÂàùÂßãÂåñ‰∏≠...');

                // Ê£ÄÊµãÊú¨Âú∞ÊúçÂä°
                updateServerStatus('checking');
                const serverConnected = await checkLocalServer();
                updateServerStatus(serverConnected ? 'connected' : 'disconnected');

                // Âä†ËΩΩÊï∞ÊçÆ
                await loadData();

                // ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨Âô®
                setupEventListeners();

                // ÂàùÂßãÊ∏≤Êüì
                renderAll();

                console.log('LLog Â∫îÁî®ÂàùÂßãÂåñÂÆåÊàê');
                console.log('Êú¨Âú∞ÊúçÂä°Áä∂ÊÄÅ:', serverConnected ? 'Â∑≤ËøûÊé•' : 'Êú™ËøûÊé•');
                console.log('Êï∞ÊçÆÂ≠òÂÇ®ÊñπÂºè:', serverConnected ? 'Êñá‰ª∂+ÊµèËßàÂô®ÂèåÈáçÂ§á‰ªΩ' : '‰ªÖÊµèËßàÂô®Â≠òÂÇ®');

            } catch (error) {
                console.error('Â∫îÁî®ÂàùÂßãÂåñÂ§±Ë¥•:', error);
            }
        }

        // ÂêØÂä®Â∫îÁî®
        document.addEventListener('DOMContentLoaded', initializeApp);

        // È°µÈù¢Âç∏ËΩΩÊó∂ÁöÑÂ§ÑÁêÜ
        window.addEventListener("beforeunload", async (e) => {
            if (hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = 'ÊúâÊú™‰øùÂ≠òÁöÑÊõ¥ÊîπÔºåÁ°ÆËÆ§Á¶ªÂºÄÔºü';

                // Â∞ùËØïÂø´ÈÄü‰øùÂ≠ò
                try {
                    await performSave(true);
                } catch (error) {
                    console.error('È°µÈù¢Âç∏ËΩΩÂâç‰øùÂ≠òÂ§±Ë¥•:', error);
                }
            }
        });
    </script>
</body>

</html>