<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LLog</title>
  <style>
    :root {
      --bg: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      --card: rgba(255, 255, 255, 0.85);
      --card-hover: rgba(255, 255, 255, 0.95);
      --accent: linear-gradient(135deg, #3b82f6, #1e40af);
      --accent-light: rgba(59, 130, 246, 0.1);
      --accent-border: rgba(59, 130, 246, 0.2);
      --muted: #64748b;
      --text: #1e293b;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --border: rgba(148, 163, 184, 0.2);
      --shadow-sm: 0 2px 8px rgba(15, 23, 42, 0.08);
      --shadow-md: 0 8px 25px rgba(15, 23, 42, 0.12);
      --shadow-lg: 0 16px 40px rgba(15, 23, 42, 0.15);
      --radius: 16px;
      --radius-sm: 10px;
      --gap: 18px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        "Helvetica Neue", Arial, sans-serif;
    }

    * {
      box-sizing: border-box;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      overflow-x: hidden;
    }

    /* Layout */
    .wrap {
      display: grid;
      grid-template-columns: 280px 1fr 280px;
      grid-template-rows: 1fr auto;
      gap: var(--gap);
      padding: var(--gap);
      height: 100vh;
      box-sizing: border-box;
    }

    header {
      grid-column: 1/-1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 16px;
      background: var(--card);
      border-radius: var(--radius);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow-sm);
      border: 1px solid var(--border);
      animation: slideDown 0.6s ease-out;
    }

    h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
      background: var(--accent);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .panel {
      background: var(--card);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow-md);
      overflow: auto;
      border: 1px solid var(--border);
      backdrop-filter: blur(10px);
      animation: fadeInUp 0.6s ease-out;
      animation-fill-mode: both;
    }

    .left {
      animation-delay: 0.1s;
    }

    .center {
      display: flex;
      flex-direction: column;
      gap: 12px;
      animation-delay: 0.2s;
    }

    .right {
      animation-delay: 0.3s;
    }

    /* Center Editor */
    .mode-bar {
      display: flex;
      gap: 6px;
      align-items: center;
      padding: 6px;
      background: var(--accent-light);
      border-radius: var(--radius-sm);
      border: 1px solid var(--accent-border);
    }

    .mode-btn {
      padding: 10px 16px;
      border-radius: var(--radius-sm);
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      color: var(--muted);
      position: relative;
      overflow: hidden;
    }

    .mode-btn:hover {
      background: rgba(255, 255, 255, 0.5);
      color: var(--text);
      transform: translateY(-1px);
    }

    .mode-btn.active {
      background: var(--accent);
      color: white;
      box-shadow: var(--shadow-sm);
      transform: translateY(-1px);
    }

    .editor {
      background: var(--card-hover);
      border-radius: var(--radius);
      padding: 18px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-sm);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    input,
    textarea,
    select {
      padding: 14px 16px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.7);
      font-family: inherit;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px var(--accent-light);
      background: white;
      transform: translateY(-1px);
    }

    textarea.large {
      min-height: 180px;
      resize: vertical;
      font-family: inherit;
    }

    .meta-row {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .actions {
      display: flex;
      gap: 12px;
      margin-top: 8px;
    }

    .btn {
      background: var(--accent);
      color: white;
      padding: 12px 24px;
      border-radius: var(--radius-sm);
      border: none;
      cursor: pointer;
      font-weight: 500;
      box-shadow: var(--shadow-sm);
      position: relative;
      overflow: hidden;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn.ghost {
      background: transparent;
      color: var(--muted);
      border: 1px solid var(--border);
    }

    .btn.ghost:hover {
      background: var(--accent-light);
      color: #3b82f6;
      border-color: var(--accent-border);
    }

    /* Lists */
    .list-title {
      font-weight: 600;
      color: var(--text);
      margin-bottom: 16px;
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .list-title::before {
      content: "";
      width: 4px;
      height: 16px;
      background: var(--accent);
      border-radius: 2px;
    }

    .task,
    .topic {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px;
      border-radius: var(--radius-sm);
      background: rgba(255, 255, 255, 0.7);
      margin-bottom: 12px;
      border: 1px solid var(--border);
      position: relative;
      cursor: pointer;
      animation: slideInLeft 0.4s ease-out;
    }

    .task:hover,
    .topic:hover {
      background: var(--card-hover);
      transform: translateY(-2px);
      box-shadow: var(--shadow-sm);
    }

    .item-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .chk {
      width: 20px;
      height: 20px;
      border-radius: 6px;
      cursor: pointer;
      accent-color: var(--success);
    }

    /* Icons */
    .more-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: all 0.2s ease;
    }

    .task:hover .more-btn,
    .topic:hover .more-btn {
      opacity: 1;
    }

    .more-btn:hover {
      background: white;
      transform: scale(1.1);
      box-shadow: var(--shadow-sm);
    }

    /* Menu */
    .menu-card {
      position: fixed;
      background: white;
      border-radius: var(--radius-sm);
      padding: 8px;
      box-shadow: var(--shadow-lg);
      z-index: 1000;
      min-width: 180px;
      border: 1px solid var(--border);
      animation: fadeIn 0.2s ease-out;
    }

    .menu-card button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      border: none;
      background: transparent;
      cursor: pointer;
      border-radius: 6px;
      font-size: 14px;
      transition: all 0.15s ease;
    }

    .menu-card button:hover {
      background: var(--accent-light);
      color: #3b82f6;
    }

    /* Timeline */
    .timeline-bar {
      grid-column: 1/-1;
      height: 140px;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: slideUp 0.6s ease-out 0.4s both;
    }

    .timeline-inner {
      width: 100%;
      max-width: 1200px;
      background: var(--card);
      border-radius: var(--radius);
      padding: 20px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-md);
      overflow: auto;
      backdrop-filter: blur(10px);
    }

    .timeline {
      display: flex;
      gap: 16px;
      align-items: center;
      padding: 12px;
    }

    .node {
      min-width: 200px;
      flex: 0 0 auto;
      padding: 16px;
      border-radius: var(--radius-sm);
      background: white;
      border: 1px solid var(--border);
      cursor: pointer;
      position: relative;
      box-shadow: var(--shadow-sm);
      animation: scaleIn 0.4s ease-out;
      animation-fill-mode: both;
    }

    .node:hover {
      transform: translateY(-4px) scale(1.02);
      box-shadow: var(--shadow-md);
      background: var(--card-hover);
    }

    .node .title {
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 160px;
      color: var(--text);
      margin-bottom: 8px;
    }

    .node time {
      display: block;
      font-size: 12px;
      color: var(--muted);
      font-weight: 500;
    }

    .node .delete-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 50%;
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .node:hover .delete-btn {
      display: flex;
    }

    .node .delete-btn:hover {
      background: rgba(239, 68, 68, 0.2);
      transform: scale(1.1);
    }

    /* Header Controls */
    #searchInput {
      width: 240px;
      padding: 6px 12px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.8);
      font-size: 14px;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideInLeft {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes scaleIn {
      from {
        opacity: 0;
        transform: scale(0.9);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* Responsive */
    @media (max-width: 1000px) {
      .wrap {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto;
      }

      .timeline-bar {
        height: 180px;
      }

      #searchInput {
        width: 200px;
      }
    }

    /* Scroll styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--muted);
    }

    /* Loading states */
    .loading {
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.7;
      }
    }

    /* Enhanced focus states */
    .btn:focus {
      outline: none;
      box-shadow: 0 0 0 3px var(--accent-light);
    }

    /* Status indicators */
    .task.completed {
      opacity: 0.7;
      background: rgba(16, 185, 129, 0.05);
    }

    .topic.completed {
      opacity: 0.7;
      background: rgba(16, 185, 129, 0.05);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <h1>âœ¨ LLog</h1>
      <div style="display: flex; gap: 8px; align-items: center">
        <input id="searchInput" placeholder="ğŸ” æœç´¢ï¼ˆæŒ‰ä¸»é¢˜æˆ–å†…å®¹ï¼‰" />
        <input id="fileImport" type="file" accept="application/json" style="display: none" />
        <label class="mode-btn" id="btnImportLbl" style="border: 1px solid var(--border); cursor: pointer">ğŸ“¥ å¯¼å…¥
          JSON</label>
        <label class="mode-btn" id="btnExport" style="border: 1px solid var(--border); cursor: pointer">ğŸ“¤ å¯¼å‡º
          JSON</label>
        <label class="mode-btn" id="btnClear" style="border: 1px solid var(--border); cursor: pointer">ğŸ—‘ï¸ æ¸…ç©º</label>
        <!-- <button class="mode-btn" id="btnExport">ğŸ“¤ å¯¼å‡º JSON</button>
          <button class="mode-btn" id="btnClear" style="color: var(--danger)">
            ğŸ—‘ï¸ æ¸…ç©º
          </button> -->
      </div>
    </header>

    <!-- left: tasks -->
    <aside class="panel left">
      <div class="list-title">ğŸ“‹ è®¡åˆ’</div>
      <div id="taskList"></div>
    </aside>

    <!-- center: big editor -->
    <main class="panel center">
      <div class="mode-bar">
        <button class="mode-btn active" data-mode="add-event">
          ğŸ“… æ·»åŠ äº‹ä»¶
        </button>
        <button class="mode-btn" data-mode="add-task">âœ… æ·»åŠ è®¡åˆ’</button>
        <button class="mode-btn" data-mode="add-topic">ğŸ·ï¸ æ·»åŠ ä¸»é¢˜</button>
        <button class="mode-btn" data-mode="edit">âœï¸ æŸ¥çœ‹ / ç¼–è¾‘</button>
        <div style="flex: 1"></div>
        <div style="color: var(--muted); font-size: 13px; font-weight: 500">
          ğŸ’¡ ç‚¹å‡»åº•éƒ¨æ—¶é—´è½´æˆ–ä¾§è¾¹é¡¹ä»¥åœ¨æ­¤æŸ¥çœ‹/ç¼–è¾‘
        </div>
      </div>

      <div class="editor">
        <input id="itemTitle" placeholder="âœï¸ æ ‡é¢˜ï¼ˆå¯¹äº‹ä»¶å–é¦–è¡Œï¼Œæˆ–ä¸»é¢˜å/ä»»åŠ¡æ ‡é¢˜ï¼‰" />
        <textarea id="itemBody" class="large" placeholder="ğŸ“ è¯¦æƒ…æˆ–ç¬”è®°ï¼ˆåœ¨è¿™é‡ŒæŸ¥çœ‹/ç¼–è¾‘å®Œæ•´å†…å®¹ï¼‰"></textarea>
        <div class="meta-row">
          <select id="bodyTopicSelect">
            <option value="">ğŸ·ï¸ å…³è”ä¸»é¢˜ï¼ˆå¯é€‰ï¼‰</option>
          </select>
          <div style="flex: 1"></div>
          <button class="btn" id="saveBtn">ğŸ’¾ ä¿å­˜</button>
          <button class="btn ghost" id="cancelBtn">âŒ å–æ¶ˆ</button>
        </div>
      </div>
    </main>

    <!-- right: topics -->
    <aside class="panel right">
      <div style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
          ">
        <div class="list-title">ğŸ·ï¸ ä¸»é¢˜</div>
      </div>
      <div id="topicList"></div>
    </aside>

    <!-- bottom timeline -->
    <div class="timeline-bar">
      <div class="timeline-inner">
        <div class="timeline" id="timeline"></div>
      </div>
    </div>
  </div>

  <script>
    // state
    const STORAGE_KEY = "timeline_v3";
    let state = { events: [], topics: [], tasks: [] };
    let mode = "add-event"; // modes: add-event, add-task, add-topic, edit
    let currentEdit = null; // {type:'event'|'topic'|'task', id}
    let autoSaveTimer = null; // æ·»åŠ è¿™è¡Œ
    let saveStatus = ""; // æ·»åŠ è¿™è¡Œ
    let hasUnsavedChanges = false;
    let hasManualSaved = false;

    // utils
    const uid = () =>
      Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
    const nowISO = () => new Date().toISOString();
    function save() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }
    function load() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw)
        try {
          state = JSON.parse(raw);
        } catch (e) {
          console.error(e);
        }
      state.events = state.events || [];
      state.topics = state.topics || [];
      state.tasks = state.tasks || [];
    }

    // small html escaper for safety when inserting innerHTML
    function escapeHtml(s) {
      return String(s || "").replace(
        /[&<>\"]/g,
        (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" }[c])
      );
    }

    // dom refs
    const taskList = document.getElementById("taskList");
    const topicList = document.getElementById("topicList");
    const timelineEl = document.getElementById("timeline");
    const titleInput = document.getElementById("itemTitle");
    const bodyInput = document.getElementById("itemBody");
    const topicSelect = document.getElementById("bodyTopicSelect");
    const saveBtn = document.getElementById("saveBtn");
    const cancelBtn = document.getElementById("cancelBtn");
    const fileImport = document.getElementById("fileImport");
    const searchInput = document.getElementById("searchInput");

    // initial load
    load();
    renderAll();
    populateTopicSelect();

    // render
    function renderAll() {
      renderTasks();
      renderTopics();
      renderTimeline();
      populateTopicSelect();
    }

    function reorderListByCheck(listName, id, checked) {
      const arr = state[listName];
      const idx = arr.findIndex((x) => x.id === id);
      if (idx === -1) return;
      const item = arr.splice(idx, 1)[0];
      item.done = !!checked;
      if (item.done) {
        // move after last unchecked
        const countUnchecked = arr.filter((x) => !x.done).length;
        arr.splice(countUnchecked, 0, item);
      } else {
        // move before first checked (or to start)
        const firstChecked = arr.findIndex((x) => x.done);
        const insertIndex = firstChecked === -1 ? 0 : firstChecked;
        arr.splice(insertIndex, 0, item);
      }
      save();
      renderAll();
    }

    function renderTasks() {
      taskList.innerHTML = "";
      state.tasks.forEach((t, idx) => {
        const div = document.createElement("div");
        div.className = "task" + (t.done ? " completed" : "");
        div.style.animationDelay = `${idx * 0.1}s`;

        const left = document.createElement("div");
        left.className = "item-left";
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.className = "chk";
        chk.checked = !!t.done;
        chk.onchange = () => {
          reorderListByCheck("tasks", t.id, chk.checked);
        };
        const txt = document.createElement("div");
        txt.innerHTML = `<div style="font-weight:500">${escapeHtml(
          t.text
        )}</div>`;
        left.appendChild(chk);
        left.appendChild(txt);
        div.appendChild(left);

        // more menu
        const mBtn = document.createElement("div");
        mBtn.className = "more-btn";
        mBtn.innerHTML = "â‹®";
        div.appendChild(mBtn);
        taskList.appendChild(div);

        // clicking the task loads into editor
        div.onclick = (e) => {
          if (
            e.target.type === "checkbox" ||
            e.target.classList.contains("more-btn") ||
            e.target.closest(".more-btn")
          )
            return;
          mode = "edit";
          currentEdit = { type: "task", id: t.id };
          setModeButton();
          loadIntoEditor("task", t.id);
        };

        // menu actions
        mBtn.onclick = (e) => {
          openMenuForElement(
            mBtn,
            [
              {
                label: "ğŸ“Œ ç½®é¡¶",
                action: () => {
                  state.tasks.splice(idx, 1);
                  state.tasks.unshift(t);
                  save();
                  renderAll();
                },
              },
              {
                label: "ğŸ“ ç½®åº•",
                action: () => {
                  state.tasks.splice(idx, 1);
                  state.tasks.push(t);
                  save();
                  renderAll();
                },
              },
              {
                label: "â¬†ï¸ ä¸Šç§»",
                action: () => {
                  if (idx > 0) {
                    state.tasks.splice(idx, 1);
                    state.tasks.splice(idx - 1, 0, t);
                    save();
                    renderAll();
                  }
                },
              },
              {
                label: "â¬‡ï¸ ä¸‹ç§»",
                action: () => {
                  if (idx < state.tasks.length - 1) {
                    state.tasks.splice(idx, 1);
                    state.tasks.splice(idx + 1, 0, t);
                    save();
                    renderAll();
                  }
                },
              },
              {
                label: "âœï¸ ç¼–è¾‘",
                action: () => {
                  mode = "edit";
                  currentEdit = { type: "task", id: t.id };
                  setModeButton();
                  loadIntoEditor("task", t.id);
                },
              },
              {
                label: "ğŸ—‘ï¸ åˆ é™¤",
                action: () => {
                  if (confirm("åˆ é™¤ä»»åŠ¡ï¼Ÿ")) {
                    state.tasks = state.tasks.filter((x) => x.id !== t.id);
                    // å¦‚æœå½“å‰æ­£åœ¨ç¼–è¾‘è¿™ä¸ªä»»åŠ¡ï¼Œæ¸…ç©ºç¼–è¾‘å™¨
                    if (
                      currentEdit &&
                      currentEdit.type === "task" &&
                      currentEdit.id === t.id
                    ) {
                      clearEditor();
                    }
                    save();
                    renderAll();
                  }
                },
              },
            ],
            e
          );
        };
      });
    }

    function renderTopics() {
      topicList.innerHTML = "";
      state.topics.forEach((t, idx) => {
        const box = document.createElement("div");
        box.className = "topic" + (t.done ? " completed" : "");
        box.style.animationDelay = `${idx * 0.1}s`;

        const left = document.createElement("div");
        left.className = "item-left";
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.className = "chk";
        chk.checked = !!t.done;
        chk.onchange = () => {
          reorderListByCheck("topics", t.id, chk.checked);
        };
        const h = document.createElement("h4");
        h.textContent = t.name;
        h.style.margin = "0";
        h.style.fontSize = "14px";
        h.style.fontWeight = "500";
        left.appendChild(chk);
        left.appendChild(h);
        box.appendChild(left);

        // click title -> view/edit
        box.onclick = (e) => {
          if (
            e.target.type === "checkbox" ||
            e.target.classList.contains("more-btn") ||
            e.target.closest(".more-btn")
          )
            return;
          mode = "edit";
          currentEdit = { type: "topic", id: t.id };
          setModeButton();
          loadIntoEditor("topic", t.id);
        };
        const mBtn = document.createElement("div");
        mBtn.className = "more-btn";
        mBtn.innerHTML = "â‹®";
        box.appendChild(mBtn);
        topicList.appendChild(box);

        // menu actions
        mBtn.onclick = (e) => {
          openMenuForElement(
            mBtn,
            [
              {
                label: "ğŸ“Œ ç½®é¡¶",
                action: () => {
                  state.topics.splice(idx, 1);
                  state.topics.unshift(t);
                  save();
                  renderAll();
                },
              },
              {
                label: "ğŸ“ ç½®åº•",
                action: () => {
                  state.topics.splice(idx, 1);
                  state.topics.push(t);
                  save();
                  renderAll();
                },
              },
              {
                label: "â¬†ï¸ ä¸Šç§»",
                action: () => {
                  if (idx > 0) {
                    state.topics.splice(idx, 1);
                    state.topics.splice(idx - 1, 0, t);
                    save();
                    renderAll();
                  }
                },
              },
              {
                label: "â¬‡ï¸ ä¸‹ç§»",
                action: () => {
                  if (idx < state.topics.length - 1) {
                    state.topics.splice(idx, 1);
                    state.topics.splice(idx + 1, 0, t);
                    save();
                    renderAll();
                  }
                },
              },
              {
                label: "âœï¸ é‡å‘½å/ç¼–è¾‘ç¬”è®°",
                action: () => {
                  mode = "edit";
                  currentEdit = { type: "topic", id: t.id };
                  setModeButton();
                  loadIntoEditor("topic", t.id);
                },
              },
              {
                label: "ğŸ—‘ï¸ åˆ é™¤",
                action: () => {
                  if (confirm("åˆ é™¤ä¸»é¢˜ï¼Ÿå¯¹åº”äº‹ä»¶å°†å–æ¶ˆå…³è”")) {
                    state.topics = state.topics.filter((x) => x.id !== t.id);
                    state.events.forEach((ev) => {
                      if (ev.topic === t.id) ev.topic = null;
                    });
                    // å¦‚æœå½“å‰æ­£åœ¨ç¼–è¾‘è¿™ä¸ªä¸»é¢˜ï¼Œæ¸…ç©ºç¼–è¾‘å™¨
                    if (
                      currentEdit &&
                      currentEdit.type === "topic" &&
                      currentEdit.id === t.id
                    ) {
                      clearEditor();
                    }
                    save();
                    renderAll();
                  }
                },
              },
            ],
            e
          );
        };
      });
    }

    function renderTimeline() {
      timelineEl.innerHTML = '';

      const q = (searchInput.value || '').trim().toLowerCase();
      const list = state.events.filter(ev => {
        if (!q) return true;
        const txt = (ev.text || '').toLowerCase();
        const topicName = ev.topic ?
          (state.topics.find(t => t.id === ev.topic) || { name: '' }).name.toLowerCase() : '';
        return txt.includes(q) || topicName.includes(q);
      });

      // show each event as node with first line/title
      list.sort((a, b) => new Date(a.ts) - new Date(b.ts));
      list.forEach((ev, idx) => {
        const node = document.createElement("div");
        node.className = "node";
        node.style.animationDelay = `${idx * 0.1}s`;

        const firstLine = (ev.text || "").split(/\n/)[0];
        const title = document.createElement("div");
        title.className = "title";
        title.textContent = firstLine || "(æ— å†…å®¹)";

        const timeEl = document.createElement("time");
        timeEl.textContent = new Date(ev.ts).toLocaleString();

        // åˆ›å»ºåˆ é™¤æŒ‰é’®
        const deleteBtn = document.createElement("button");
        deleteBtn.innerHTML = "Ã—";
        deleteBtn.className = "delete-btn";

        // åˆ é™¤æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          if (confirm("ç¡®è®¤åˆ é™¤è¿™ä¸ªäº‹ä»¶ï¼Ÿ")) {
            state.events = state.events.filter((event) => event.id !== ev.id);
            save();
            renderAll();
            if (
              currentEdit &&
              currentEdit.type === "event" &&
              currentEdit.id === ev.id
            ) {
              clearEditor();
            }
          }
        };

        node.appendChild(title);
        node.appendChild(timeEl);
        node.appendChild(deleteBtn);
        timelineEl.appendChild(node);

        node.onclick = () => {
          mode = "edit";
          currentEdit = { type: "event", id: ev.id };
          setModeButton();
          loadIntoEditor("event", ev.id);
          node.scrollIntoView({ behavior: "smooth", inline: "center" });
        };
      });
    }

    function populateTopicSelect() {
      topicSelect.innerHTML = '<option value="">ğŸ·ï¸ (ä¸å…³è”)</option>';
      state.topics
        .filter((t) => t.done !== true)
        .forEach((t) => {
          const o = document.createElement("option");
          o.value = t.id;
          o.textContent = t.name;
          topicSelect.appendChild(o);
        });
    }

    // editor logic
    function clearEditor() {
      titleInput.value = '';
      bodyInput.value = '';
      topicSelect.value = '';
      currentEdit = null;
      hasUnsavedChanges = false;
      hasManualSaved = false;
    }

    function loadIntoEditor(type, id) {
      if (type === 'event') {
        const ev = state.events.find(x => x.id === id);
        if (!ev) return;
        titleInput.value = (ev.text || '').split(/\n/)[0];
        bodyInput.value = ev.text;
        topicSelect.value = ev.topic || '';
      }
      if (type === 'topic') {
        const t = state.topics.find(x => x.id === id);
        if (!t) return;
        titleInput.value = t.name;
        bodyInput.value = t.notes || '';
        topicSelect.value = '';
      }
      if (type === 'task') {
        const tk = state.tasks.find(x => x.id === id);
        if (!tk) return;
        titleInput.value = tk.text;
        bodyInput.value = '';
        topicSelect.value = '';
      }

      // è®°å½•åˆå§‹å€¼ç”¨äºå˜åŒ–æ£€æµ‹
      hasUnsavedChanges = false;
      hasManualSaved = false;
    }

    function setupAutoSaveDetection() {
      let originalTitle = '';
      let originalBody = '';
      let originalTopic = '';

      // è®°å½•åˆå§‹å€¼
      function recordInitialValues() {
        originalTitle = titleInput.value;
        originalBody = bodyInput.value;
        originalTopic = topicSelect.value;
        hasUnsavedChanges = false;
        hasManualSaved = false;
      }

      // æ£€æµ‹æ˜¯å¦æœ‰å˜åŒ–
      function detectChanges() {
        const hasChanges =
          titleInput.value !== originalTitle ||
          bodyInput.value !== originalBody ||
          topicSelect.value !== originalTopic;

        hasUnsavedChanges = hasChanges && !hasManualSaved;
        return hasChanges;
      }

      // ç›‘å¬è¾“å…¥å˜åŒ–
      titleInput.addEventListener('input', detectChanges);
      bodyInput.addEventListener('input', detectChanges);
      topicSelect.addEventListener('change', detectChanges);

      return { recordInitialValues, detectChanges };
    }

    // 3. è‡ªåŠ¨ä¿å­˜å‡½æ•°
    function autoSave() {
      if (autoSaveTimer) clearTimeout(autoSaveTimer);
      autoSaveTimer = setTimeout(() => {
        if (mode === "edit" && currentEdit) {
          performSave(true); // trueè¡¨ç¤ºè‡ªåŠ¨ä¿å­˜
        }
      }, 10000); // 10ç§’å»¶è¿Ÿ
    }

    // æ‰§è¡Œä¿å­˜çš„æ ¸å¿ƒå‡½æ•°
    function performSave(isAutoSave = false) {
      const title = titleInput.value.trim();
      const body = bodyInput.value.trim();
      const topicId = topicSelect.value || null;

      if (mode === "edit" && currentEdit) {
        if (!title && !body) return; // ç©ºå†…å®¹ä¸ä¿å­˜

        try {
          if (currentEdit.type === "event") {
            const ev = state.events.find((x) => x.id === currentEdit.id);
            if (!ev) return;
            if (!title) {
              if (isAutoSave) return; // è‡ªåŠ¨ä¿å­˜æ—¶æ ‡é¢˜ä¸ºç©ºåˆ™è·³è¿‡
              alert("è¯·è¾“å…¥äº‹ä»¶æ ‡é¢˜");
              return;
            }
            const text = title + (body ? "\n" + body : "");
            ev.text = text;
            ev.topic = topicId || null;
          }

          if (currentEdit.type === "topic") {
            const t = state.topics.find((x) => x.id === currentEdit.id);
            if (!t) return;
            if (!title) {
              if (isAutoSave) return;
              alert("è¯·è¾“å…¥ä¸»é¢˜å");
              return;
            }
            // æ£€æŸ¥é‡å
            if (title.toLowerCase() !== t.name.trim().toLowerCase()) {
              const exists = state.topics.find(
                (x) => x.name.trim().toLowerCase() === title.toLowerCase()
              );
              if (exists) {
                if (isAutoSave) return;
                alert("å­˜åœ¨åŒåä¸»é¢˜");
                return;
              }
              t.name = title.trim();
            }
            t.notes = body;
          }

          if (currentEdit.type === "task") {
            const tk = state.tasks.find((x) => x.id === currentEdit.id);
            if (!tk) return;
            if (!title) {
              if (isAutoSave) return;
              alert("è¯·è¾“å…¥ä»»åŠ¡æ ‡é¢˜");
              return;
            }
            tk.text = title;
            tk.notes = body;
          }

          save();
          renderAll();
          showSaveStatus(isAutoSave ? "å·²è‡ªåŠ¨ä¿å­˜" : "å·²ä¿å­˜");
        } catch (error) {
          console.error("ä¿å­˜å¤±è´¥:", error);
          if (!isAutoSave) alert("ä¿å­˜å¤±è´¥");
        }
      }
    }

    // æ˜¾ç¤ºä¿å­˜çŠ¶æ€
    function showSaveStatus(message) {
      saveStatus = message;
      updateSaveButton();
      setTimeout(() => {
        saveStatus = "";
        updateSaveButton();
      }, 2000);
    }

    // æ›´æ–°ä¿å­˜æŒ‰é’®æ˜¾ç¤º
    function updateSaveButton() {
      if (saveStatus) {
        saveBtn.textContent = saveStatus;
        saveBtn.style.background = "var(--success)";
      } else {
        saveBtn.textContent = "ğŸ’¾ ä¿å­˜";
        saveBtn.style.background = "var(--accent)";
      }
    }

    // save handler
    const originalSaveBtn = saveBtn.onclick;
    saveBtn.onclick = async () => {
      const title = titleInput.value.trim();
      const body = bodyInput.value.trim();
      const topicId = topicSelect.value || null;

      if (mode === 'add-event') {
        if (!body && !title) {
          alert('è¯·è¾“å…¥äº‹ä»¶å†…å®¹');
          return;
        }
        const text = body || title;
        addEvent(text, nowISO(), topicId);
        clearEditor();
      } else if (mode === 'add-task') {
        if (!title) {
          alert('è¯·è¾“å…¥ä»»åŠ¡æ ‡é¢˜');
          return;
        }
        addTask(title);
        clearEditor();
      } else if (mode === 'add-topic') {
        if (!title) {
          alert('è¯·è¾“å…¥ä¸»é¢˜å');
          return;
        }
        const res = addTopic(title);
        if (!res.ok) {
          alert(res.msg);
          return;
        }
        updateTopic(res.t.id, { notes: body });
        clearEditor();
      } else if (mode === 'edit') {
        if (!currentEdit) {
          alert('æœªé€‰æ‹©è¦ç¼–è¾‘çš„æ¡ç›®');
          return;
        }
        if (currentEdit.type === 'event') {
          const ev = state.events.find(x => x.id === currentEdit.id);
          if (!ev) return;
          ev.text = body || title;
          ev.topic = topicId || null;
          await save();
          renderAll();
        }
        if (currentEdit.type === 'topic') {
          const t = state.topics.find(x => x.id === currentEdit.id);
          if (!t) return;
          if (title.trim().toLowerCase() !== t.name.trim().toLowerCase()) {
            const exists = state.topics.find(x =>
              x.name.trim().toLowerCase() === title.trim().toLowerCase()
            );
            if (exists) {
              alert('å­˜åœ¨åŒåä¸»é¢˜');
              return;
            }
            t.name = title.trim();
          }
          t.notes = body;
          await save();
          renderAll();
        }
        if (currentEdit.type === 'task') {
          const tk = state.tasks.find(x => x.id === currentEdit.id);
          if (!tk) return;
          tk.text = title;
          await save();
          renderAll();
        }
      }

      hasManualSaved = true; // æ ‡è®°å·²æ‰‹åŠ¨ä¿å­˜
      hasUnsavedChanges = false;
    };


    cancelBtn.onclick = () => {
      clearEditor();
    };

    // helper: add functions that update state and render
    function addEvent(text, ts = null, topic = null) {
      const ev = {
        id: uid(),
        ts: ts || nowISO(),
        text: text,
        topic: topic || null,
      };
      state.events.push(ev);
      save();
      renderAll();
    }
    function addTask(text) {
      const task = {
        id: uid(),
        text,
        done: false,
        createdAt: nowISO() // æ·»åŠ åˆ›å»ºæ—¶é—´
      };
      state.tasks.unshift(task); // æ–°ä»»åŠ¡ç½®é¡¶
      save();
      renderAll();
    }
    function addTopic(name) {
      if (!name) return { ok: false, msg: 'åç§°ä¸ºç©º' };
      const exists = state.topics.find(t =>
        t.name.trim().toLowerCase() === name.trim().toLowerCase()
      );
      if (exists) return { ok: false, msg: 'ä¸»é¢˜å·²å­˜åœ¨' };

      const t = {
        id: uid(),
        name: name.trim(),
        notes: '',
        done: false,
        createdAt: nowISO() // æ·»åŠ åˆ›å»ºæ—¶é—´
      };

      state.topics.unshift(t); // æ–°ä¸»é¢˜ç½®é¡¶
      save();
      renderAll();
      return { ok: true, t };
    }


    function updateTopic(id, data) {
      const t = state.topics.find((x) => x.id === id);
      if (!t) return;
      Object.assign(t, data);
      save();
      renderAll();
    }

    // open contextual menu below an element (improved toggle + auto-close)
    function openMenuForElement(anchor, items, event) {
      // items: [{label,action}]
      // if there is already a menu inside this parent, toggle it off
      const parent = anchor.parentElement;
      const existing = parent.querySelector(".menu-card");
      if (existing) {
        existing.remove();
        return;
      }
      // close any other menus
      document.querySelectorAll(".menu-card").forEach((n) => n.remove());
      if (event) {
        event.stopPropagation();
      }
      const card = document.createElement("div");
      card.className = "menu-card";
      card.onclick = (e) => {
        e.stopPropagation();
      }; // prevent outside click closing when interacting with menu
      items.forEach((it) => {
        const btn = document.createElement("button");
        btn.textContent = it.label;
        btn.onclick = (() => {
          return () => {
            try {
              it.action();
            } catch (e) {
              console.error(e);
            }
            card.remove();
          };
        })();
        card.appendChild(btn);
      });
      // attach to the anchor's parent so it stays within panel
      // å°†èœå•æ·»åŠ åˆ°bodyï¼Œé¿å…çˆ¶å…ƒç´ äº‹ä»¶å½±å“
      // å…ˆæ·»åŠ åˆ°bodyä»¥ä¾¿æµ‹é‡å®é™…é«˜åº¦
      document.body.appendChild(card);

      // é‡æ–°è®¡ç®—ä½ç½®ï¼Œç›¸å¯¹äºé¡µé¢å®šä½
      const rect = anchor.getBoundingClientRect();
      card.style.position = "fixed";
      card.style.left = rect.right - 180 + "px";

      // è·å–èœå•å®é™…é«˜åº¦
      const menuHeight = card.offsetHeight;
      const spaceBelow = window.innerHeight - rect.bottom - 10; // ç•™10pxç¼“å†²
      const spaceAbove = rect.top - 10;

      if (spaceBelow < menuHeight && spaceAbove >= menuHeight) {
        // å‘ä¸Šå±•å¼€
        card.style.top = rect.top - menuHeight - 5 + "px";
      } else {
        // å‘ä¸‹å±•å¼€
        card.style.top = rect.bottom + 5 + "px";
      }
    }

    // close menus when clicking outside
    document.addEventListener("click", (e) => {
      // å¦‚æœç‚¹å‡»çš„ä¸æ˜¯èœå•å†…å®¹ï¼Œåˆ™å…³é—­èœå•
      if (!e.target.closest(".menu-card") && !e.target.closest(".more-btn")) {
        document.querySelectorAll(".menu-card").forEach((n) => n.remove());
      }
    });

    // mode buttons
    document.querySelectorAll(".mode-btn").forEach((b) => {
      b.onclick = () => {
        // åˆ‡æ¢å‰è‡ªåŠ¨ä¿å­˜å½“å‰ç¼–è¾‘
        if (
          mode === "edit" &&
          currentEdit &&
          (titleInput.value.trim() || bodyInput.value.trim())
        ) {
          performSave(true);
        }

        document
          .querySelectorAll(".mode-btn")
          .forEach((x) => x.classList.remove("active"));
        b.classList.add("active");
        mode = b.dataset.mode;
        clearEditor();
      };
    });
    function setModeButton() {
      document
        .querySelectorAll(".mode-btn")
        .forEach((x) => x.classList.remove("active"));
      const btn = Array.from(document.querySelectorAll(".mode-btn")).find(
        (b) => b.dataset.mode === mode
      );
      if (btn) btn.classList.add("active");
    }

    // search input behavior: re-render timeline on input
    searchInput.addEventListener("input", () => {
      renderTimeline();
    });

    // JSON import/export
    const btnExport = document.getElementById("btnExport");
    btnExport.onclick = () => {
      const blob = new Blob([JSON.stringify(state, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download =
        "timeline_export_" +
        new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-") +
        ".json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    };

    const btnImportLbl = document.getElementById("btnImportLbl");
    btnImportLbl.onclick = () => fileImport.click();
    fileImport.onchange = (e) => {
      const f = e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const imported = JSON.parse(ev.target.result);
          if (!imported) throw new Error("æ ¼å¼é”™è¯¯");
          const overwrite = confirm("ç¡®è®¤è¦†ç›–å½“å‰æ•°æ®ï¼Ÿç‚¹ [ç¡®å®š] = è¦†ç›–");
          if (overwrite) {
            state = imported;
          } else {
            return;
          }
          save();
          renderAll();
          alert("å¯¼å…¥å®Œæˆ");
        } catch (err) {
          alert("å¯¼å…¥å¤±è´¥ï¼š" + err.message);
        }
      };
      reader.readAsText(f);
      e.target.value = null;
    };

    const btnClear = document.getElementById("btnClear");
    btnClear.onclick = () => {
      if (confirm("æ¸…ç©ºæ‰€æœ‰æ•°æ®ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼Œå°†å…ˆè‡ªåŠ¨å¯¼å‡ºå¤‡ä»½")) {
        // å…ˆè‡ªåŠ¨å¯¼å‡ºå¤‡ä»½
        try {
          const blob = new Blob([JSON.stringify(state, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download =
            "timeline_backup_before_clear_" +
            new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-") +
            ".json";
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error("å¤‡ä»½å¯¼å‡ºå¤±è´¥:", error);
          if (!confirm("å¤‡ä»½å¯¼å‡ºå¤±è´¥ï¼Œæ˜¯å¦ä»è¦ç»§ç»­æ¸…ç©ºï¼Ÿ")) return;
        }

        // æ‰§è¡Œæ¸…ç©ºæ“ä½œ
        state = { events: [], topics: [], tasks: [] };
        save();
        renderAll();
        alert("æ•°æ®å·²æ¸…ç©ºï¼Œå¤‡ä»½å·²è‡ªåŠ¨ä¸‹è½½");
      }
    };

    // utility functions used earlier (delete via editor for events)
    function deleteEventById(id) {
      if (confirm("åˆ é™¤è¯¥äº‹ä»¶ï¼Ÿ")) {
        state.events = state.events.filter((e) => e.id !== id);
        save();
        renderAll();
      }
    }

    // expose delete function in editor via keyboard shortcut: Ctrl+Delete deletes current edit (convenience)
    document.addEventListener("keydown", (e) => {
      if (e.ctrlKey && e.key === "Delete" && currentEdit) {
        if (currentEdit.type === "event") deleteEventById(currentEdit.id);
        if (currentEdit.type === "topic") {
          if (confirm("åˆ é™¤ä¸»é¢˜ï¼Ÿ")) {
            state.topics = state.topics.filter(
              (t) => t.id !== currentEdit.id
            );
            state.events.forEach((ev) => {
              if (ev.topic === currentEdit.id) ev.topic = null;
            });
            save();
            renderAll();
          }
        }
        if (currentEdit.type === "task") {
          if (confirm("åˆ é™¤ä»»åŠ¡ï¼Ÿ")) {
            state.tasks = state.tasks.filter((x) => x.id !== currentEdit.id);
            save();
            renderAll();
          }
        }
      }
    });
    // æ·»åŠ è¾“å…¥ç›‘å¬ä»¥è§¦å‘è‡ªåŠ¨ä¿å­˜
    titleInput.addEventListener("input", autoSave);
    bodyInput.addEventListener("input", autoSave);
    topicSelect.addEventListener("change", autoSave);
    // initial render update
    renderAll();
    // é¡µé¢å¸è½½æ—¶è‡ªåŠ¨å¯¼å‡ºJSON
    window.addEventListener("beforeunload", function (e) {
      // æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®éœ€è¦å¯¼å‡º
      if (
        state.events.length > 0 ||
        state.topics.length > 0 ||
        state.tasks.length > 0
      ) {
        try {
          // åˆ›å»ºå¹¶ä¸‹è½½JSONæ–‡ä»¶
          const blob = new Blob([JSON.stringify(state, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download =
            "timeline_auto_backup_" +
            new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-") +
            ".json";
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error("è‡ªåŠ¨å¯¼å‡ºå¤±è´¥:", error);
        }
      }
    });
    document.addEventListener('DOMContentLoaded', () => {
      setupAutoSaveDetection();
    });
  </script>
</body>

</html>